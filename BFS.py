from collections import deque
import maze_runner
from CheckNeighbours import check_neighbours

'''
BFS algorithm 
- Takes as input the dimension and probability of a maze
- Explores in the order of oldest cells in the fringe
- Constructs the shortest path from source to goal
'''

# Dimension of the maze and probability for which the maze is occupied
dim = 120
probability = 0.2

# generate maze
maze = maze_runner.get_maze(dim, probability)
result = 0
closed_set = []
fringe = deque()
path = []
# initial state of fringe
fringe.append((0, 0))

while len(fringe) != 0:
    # pop tuple from left and analyze
    current = fringe.popleft()
    m = current[0]
    n = current[1]
    if current not in closed_set:
        # if current cell is the goal
        if maze[m][n].value == 3:
            result = 1
            break
        else:
            if maze[m][n].value != 1:
                # call method to explore neighbouring cells of current cell
                check_neighbours(maze, dim, m, n, fringe, closed_set)
            # add current cell to closed set
            closed_set.append(current)

if result == 0:
    print "No Path Found"
    maze_runner.visualize_maze(maze)
else:
    # visualize path generated by BFS on maze
    path = maze_runner.get_path(m, n, maze)
    maze_runner.trace_path(maze, path)
